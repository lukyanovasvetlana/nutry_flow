# Документ Архитектуры {Название Проекта}

## Введение / Преамбула

{Этот документ описывает общую архитектуру проекта, включая бэкенд-системы, общие сервисы и не связанные с UI аспекты. Его основная цель — служить руководящим архитектурным планом для разработки с помощью AI, обеспечивая согласованность и adherence к выбранным шаблонам и технологиям.\n\n**Взаимосвязь с Архитектурой Фронтенда:**\nЕсли проект включает значительный пользовательский интерфейс (как в случае с мобильным Flutter приложением), отдельный Документ Архитектуры Фронтенда (обычно называемый `front-end-architecture-tmpl.txt` или аналогичный, и связанный в разделе \"Ключевые Ссылочные Документы\") подробно описывает дизайн, специфичный для фронтенда, и ДОЛЖЕН использоваться совместно с этим документом. Выбор основного технологического стека, задокументированный здесь (см. \"Окончательный Выбор Технологического Стека\"), является определяющим для всего проекта, включая любые фронтенд-компоненты.}

## Оглавление

{ Обновите это, если разделы и подразделы добавляются или удаляются }

## Техническое Резюме

{ Предоставьте краткий обзор архитектуры системы, ключевых компонентов, выбора технологий и используемых архитектурных шаблонов. Ссылайтесь на цели из PRD. Для Flutter/Chibis App, упомяните feature-based структуру, Clean Architecture, использование BLoC/Cubit для стейт-менеджмента, GetIt для DI, интеграции с Supabase и Firebase. }

## Высокоуровневый Обзор

{ Опишите основной архитектурный стиль (например, Монолит, Микросервисы, Serverless, Event-Driven), отражая решение, принятое в PRD. Объясните структуру репозитория (Monorepo/Polyrepo). Объясните основной пользовательский поток взаимодействия или поток данных на концептуальном уровне. Для Flutter/Chibis App опишите, как мобильное приложение взаимодействует с бэкендом (Supabase/Firebase) и внешними сервисами. }

{ Вставьте высокоуровневую mermaid диаграмму системного контекста или взаимодействия здесь - например, Mermaid Class C4 Models Уровень 1 и 2 }

## Принятые Архитектурные / Дизайн Шаблоны

{ Перечислите ключевые высокоуровневые шаблоны, выбранные для архитектуры. Эти фундаментальные шаблоны должны быть установлены на раннем этапе, так как они определяют дизайн компонентов, взаимодействия и выбор технологий. }

- **Шаблон 1:** {например, Serverless, Event-Driven, Microservices, CQRS} - _Обоснование/Ссылка:_ {Кратко почему, или ссылка на более подробное объяснение, если необходимо}
- **Шаблон 2:** {например, Dependency Injection, Repository Pattern, Module Pattern} - _Обоснование/Ссылка:_ {...}
- **Шаблон N:** {...}

## Вид Компонентов

{ Опишите основные логические компоненты или сервисы системы и их обязанности, отражая принятую общую архитектуру (например, отдельные микросервисы, модули внутри монолита, пакеты внутри монорепо) и принятые архитектурные шаблоны. Объясните, как они взаимодействуют. Для Flutter/Chibis App опишите такие логические компоненты, как модули фич, Core (утилиты, темы, виджеты), и как они взаимодействуют с Domain и Data слоями. }

- Компонент A: {Описание обязанности}

{Вставьте диаграмму компонентов здесь, если это помогает - например, с использованием Mermaid graph TD или C4 Model Container/Component Diagram}

- Компонент N...: {Описание обязанности}

{ Вставьте диаграмму компонентов здесь, если это помогает - например, с использованием Mermaid graph TD или C4 Model Container/Component Diagram }

## Структура Проекта

{ Предоставьте ASCII или Mermaid диаграмму, представляющую структуру папок проекта. Следующий пример является общим. Если используется `front-end-architecture-tmpl.txt` (или эквивалент), он будет содержать подробную структуру для фронтенд-части (например, внутри `lib/` или выделенной корневой директории `frontend/`). Структура общего кода (например, в директории `packages/` для монорепо) также должна быть подробно описана здесь. Адаптируйте структуру под типичную feature-based архитектуру Flutter. }

```plaintext
{project-root}/
├── .github/                    # CI/CD workflows (e.g., GitHub Actions)
│   └── workflows/
│       └── main.yml
├── .vscode/                    # VSCode settings (optional)
│   └── settings.json
├── build/                      # Скомпилированный вывод (если применимо, часто git-ignored)
├── config/                     # Статические файлы конфигурации (если есть)
├── docs/                       # Документация проекта (PRD, Arch и т.д.)
│   ├── index.md
│   └── ... (другие .md файлы)
├── lib/                        # Исходный код приложения Flutter
│   ├── core/                   # Общий код (константы, темы, утилиты, общие виджеты)
│   │   ├── constants/
│   │   ├── theme/
│   │   ├── utils/
│   │   └── widgets/
│   ├── features/               # Код, специфичный для отдельных фич (feature-based architecture)
│   │   └── feature_name/       # Пример фичи
│   │       ├── data/           # Data Layer (источники данных, модели, репозитории имплементации)
│   │       │   ├── datasources/
│   │       │   ├── models/
│   │       │   └── repositories/
│   │       ├── domain/         # Domain Layer (сущности, репозитории интерфейсы, use cases)
│   │       │   ├── entities/
│   │       │   ├── repositories/
│   │       │   └── usecases/
│   │       └── presentation/   # Presentation Layer (BLoC/Cubit, страницы, виджеты)
│   │           ├── bloc/
│   │           ├── pages/
│   │           └── widgets/
│   ├── l10n/                   # Файлы локализации
│   └── main.dart               # Точка входа в приложение
├── test/                       # Автоматизированные тесты
│   ├── unit/                   # Модульные тесты
│   ├── widget/                 # Виджет-тесты
│   └── integration/            # Интеграционные тесты
├── .env.example                # Пример переменных окружения
├── .gitignore                  # Правила Git Ignore
├── pubspec.yaml                # Манифест проекта Flutter и зависимости
├── analysis_options.yaml       # Правила анализа кода Dart/Flutter
└── README.md                   # Обзор проекта и инструкции по настройке
```

(Адаптируйте пример дерева на основе фактического типа проекта Flutter. Указанная выше структура иллюстрирует feature-based подход.)

### Описание Ключевых Директорий

- docs/: Содержит всю документацию по планированию и reference по проекту.
- lib/: Содержит основной исходный код приложения Flutter.
- lib/core/: Общий код, используемый в нескольких фичах.
- lib/features/: Код, специфичный для каждой отдельной фичи.
- lib/features/.../data/: Data Layer - имплементации репозиториев, модели данных, источники данных (например, для взаимодействия с Supabase/Firebase).
- lib/features/.../domain/: Domain Layer - чистые бизнес-сущности, интерфейсы репозиториев, Use Cases.
- lib/features/.../presentation/: Presentation Layer - UI и логика представления (BLoC/Cubit).
- test/: Содержит все автоматизированные тесты (unit, widget, integration).

### Примечания

{ Упомяните любые специфические пути вывода сборки, указатели на конфигурацию компилятора или другие соответствующие структурные примечания для Flutter. }

## API Reference

### Используемые Внешние API

{ Повторите этот раздел для каждого внешнего API, с которым взаимодействует система. Включите сюда Supabase и Firebase, если они используются через их SDK/API. }

#### {Название Внешнего Сервиса}

- **Назначение:** {Зачем система использует этот API?}
- **Базовый URL(ы):**
  - Production: `{URL}`
  - Staging/Dev: `{URL}`
- **Аутентификация:** {Опишите метод - например, API Key в заголовке (Название заголовка: `X-API-Key`), OAuth 2.0 Client Credentials, Basic Auth. Ссылайтесь на `docs/environment-vars.md` для названий ключей. Для Supabase/Firebase укажите используемые методы аутентификации (например, Anon Key, JWT).}
- **Используемые Ключевые Эндпоинты:**
  - **`{HTTP Метод} {/путь/к/эндпоинту}`:**
    - Описание: {Что делает этот эндпоинт?}
    - Параметры Запроса: {Query params, path params}
    - Схема Тела Запроса: {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если схема исключительно велика или сложна.}
    - Пример Запроса: ```{Код блок}```
    - Схема Успешного Ответа (Код: `200 OK`): {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если очень сложна.}
    - Схема(ы) Ошибочного Ответа (Коды: `4xx`, `5xx`): {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если очень сложна.}
    - Пример Ответа: ```{Код блок}```
  - **`{HTTP Метод} {/другой/эндпоинту}`:** {...}
- **Ограничения Скорости (Rate Limits):** {Если известны}
- **Ссылка на Официальную Документацию:** {URL}

### Предоставляемые Внутренние API (Если применимо)

{ Если система предоставляет свои собственные API (например, в микросервисной архитектуре или для UI фронтенда). Повторите для каждого API. }

#### {Название Внутреннего API / Сервиса}

- **Назначение:** {Какую услугу предоставляет этот API?}
- **Базовый URL(ы):** {например, `/api/v1/...`}
- **Аутентификация/Авторизация:** {Опишите, как контролируется доступ.}
- **Эндпоинты:**
  - **`{HTTP Метод} {/путь/к/эндпоинту}`:**
    - Описание: {Что делает этот эндпоинт?}
    - Параметры Запроса: {...}
    - Схема Тела Запроса: {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если очень сложна.}
    - Схема Успешного Ответа (Код: `200 OK`): {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если очень сложна.}
    - Схема(ы) Ошибочного Ответа (Коды: `4xx`, `5xx`): {Предоставьте схему JSON inline, или ссылку на подробное определение в `docs/data-models.md` только если очень сложна.}
  - **`{HTTP Метод} {/другой/эндпоинту}`:** {...}

## Модели Данных

### Основные Сущности Приложения / Объекты Домена

{ Определите основные объекты/концепции, с которыми работает приложение. Повторите подраздел для каждой ключевой сущности, определенной в Domain Layer. }

#### {Название Сущности, например, User, Order, Product}

- **Описание:** {Что представляет эта сущность?}
- **Определение Схемы / Интерфейса:**
  ```dart
  // Пример с использованием Dart класса или Freezed/Equitable
  class {EntityName} {
    final String id; // {Описание, например, Уникальный идентификатор}
    final String propertyName; // {Описание}
    final int? optionalProperty; // {Описание}
    // ... другие свойства

    {EntityName}({required this.id, required this.propertyName, this.optionalProperty});

    // Добавьте fromJson/toJson методы, если применимо
  }
  ```
- **Правила Валидации:** { Перечислите любые специфические правила валидации помимо базовых типов - например, максимальная длина, формат, диапазон. }

### Схемы API Payload (Если отличаются)

{ Определите схемы здесь только если они отличаются от основных сущностей И НЕ полностью детализированы в определениях эндпоинтов API в разделе API Reference. Предпочтительно детализировать схемы запроса/ответа непосредственно с их API там, где это возможно. Этот раздел предназначен для сложных, переиспользуемых структур payload, которые могут использоваться в нескольких внутренних API или значительно отличаться от основных персистентных сущностей. }

#### {Эндпоинт / Назначение API, например, Запрос на создание заказа, повторите раздел по мере необходимости}

- **Определение Схемы / Интерфейса:**
  ```dart
  // Пример Dart класса или Freezed
  class CreateOrderRequest {
    final String customerId;
    final List<Map<String, dynamic>> items;
    // ...

    CreateOrderRequest({required this.customerId, required this.items});

    // Добавьте fromJson/toJson методы, если применимо
  }
  ```

### Схемы Базы Данных (Если применимо)

{ Если используется база данных (например, PostgreSQL через Supabase), определите структуры таблиц. Повторите по мере необходимости. }

#### {Название Таблицы / Коллекции}

- **Назначение:** {Какие данные хранит эта таблица?}
- **Определение Схемы:**
  ```sql
  -- Пример SQL для PostgreSQL (Supabase)
  CREATE TABLE {TableName} (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    column_name VARCHAR(255) NOT NULL,
    numeric_column DECIMAL(10, 2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- ... другие колонки, индексы, ограничения
  );
  ```
  _(Альтернативно, используйте определения моделей ORM, структуру документов NoSQL и т.д.)_

## Основной Рабочий Процесс / Диаграммы Последовательности

{ Проиллюстрируйте ключевые или сложные рабочие процессы с использованием mermaid диаграмм последовательности. Могут быть высокоуровневые диаграммы, связывающие весь проект, а также меньшие диаграммы уровня эпиков. }

## Окончательный Выбор Технологического Стека

{ Этот раздел описывает окончательный выбор технологий для проекта. Этот выбор должен быть сделан после тщательного понимания требований проекта, компонентов, моделей данных и основных рабочих процессов. Агент-Архитектор должен помочь пользователю принять эти решения, обеспечивая, что каждый выбор обоснован и точно записан в таблице ниже.\n\nЭта таблица является **единственным источником истины** для всех технологических выборов. Другие архитектурные документы (например, Архитектура Фронтенда) должны ссылаться на эти выборы и подробно описывать их специфическое применение, а не переопределять их.\n\nКлючевые решения для обсуждения и окончательного утверждения здесь, которые затем будут расширены и формально задокументированы в подробной таблице стека ниже, включают соображения, такие как:\n\n- Предпочтительный Шаблон-Стартер Фронтенда: { Url на шаблон или стартер, если используется }\n- Предпочтительный Шаблон-Стартер Бэкенда: { Url на шаблон или стартер, если используется }\n- Основной Язык(и) & Версия(и): { например, Dart 3.x - Укажите точные версии, например, `3.3.0` }\n- Основная Среда Выполнения (Runtime) & Версия(и): { например, Flutter 3.x - Укажите точные версии, например, `3.19.0`}\n\nВыбор должен быть окончательным; не перечисляйте открытые варианты (например, для парсинга веба, выберите один инструмент, а не два). Укажите точные версии (например, `18.2.0`). Если используется 'Latest', это подразумевает последнюю стабильную версию _на момент последнего обновления этого документа_, и конкретная версия (например, `xyz-library@2.3.4`) должна быть записана. Привязка версий настоятельно рекомендуется, чтобы избежать неожиданных критических изменений для AI агента. }

| Категория             | Технология              | Версия / Детали | Описание / Назначение                   | Обоснование (Опционально) |
| :------------------- | :---------------------- | :---------------- | :-------------------------------------- | :----------------------- |
| **Языки**            | Dart                    | {например, 3.x}       | Основной язык для разработки Flutter   |                          |
| **Фреймворки**       | Flutter                 | {например, 3.x}      | Фреймворк для создания мобильных UI    |                          |
|                      | Clean Architecture      | N/A               | Архитектурный шаблон для структуры кода |                          |
|                      | Feature-based Structure | N/A               | Организация кода по фичам             |                          |
| **Стейт-менеджмент** | BLoC / Cubit            | {например, latest} | Управление состоянием приложения Flutter |                          |
| **Внедрение Зависимостей** | GetIt                 | {например, latest} | Инструмент для Dependency Injection     |                          |
| **Базы Данных**      | PostgreSQL (via Supabase)| {например, 15}        | Основное реляционное хранилище данных (бэкенд) |                          |
| **Бэкенд как Сервис**| Supabase                | N/A               | Аутентификация, База данных, Файловое хранилище, Функции |                          |
| **Облачные Сервисы** | Firebase                | N/A               | Аналитика, Крэш-репорты, Удаленная конфигурация |                          |
| **Навигация**        | GoRouter                | {например, latest} | Роутинг и навигация в приложении Flutter |                          |
| **Тестирование**     | `flutter test`          | N/A               | Инструмент для запуска тестов Flutter (Unit, Widget, Integration) |                          |
|                      | mocktail /mockito      | {например, latest} | Инструменты для мокирования/стаббинга |                          |
| **CI/CD**            | GitHub Actions / GitLab CI / etc. | N/A       | Инструменты для Continuous Integration/Deployment |                          |
| **Другие Инструменты** |                               |                   |                                         |                          |
|                      |                               |                   |                                         |                          |

## Инфраструктура и Обзор Развертывания

- Облачный Провайдер(ы): { например, Supabase, Firebase, возможно, дополнительно AWS/GCP/Azure для специфических нужд }
- Используемые Основные Сервисы: { Перечислите ключевые управляемые сервисы - например, Supabase (Auth, Database, Storage, Functions), Firebase (Analytics, Crashlytics, Remote Config) }
- Инфраструктура как Код (IaC): { Инструмент - например, Supabase CLI, возможно, CDK/Terraform для облачной инфраструктуры, если используется } - Местоположение: { Ссылка на репозиторий/директорию IaC кода }
- Стратегия Развертывания: { например, CI/CD пайплайн с автоматизированным развертыванием на тестовые/продакшн среды (например, через Fastlane, Codemagic или кастомные скрипты в CI) } - Инструменты: { например, GitHub Actions, GitLab CI, Fastlane, Codemagic }
- Среды: { Перечислите среды - например, Development, Staging, Production }
- Промоушен Среды: { Опишите шаги, например, `dev` -> `staging` (ручное утверждение / пройдены автоматические тесты) -> `production` (автоматически после прохождения тестов и опционального ручного утверждения) }
- Стратегия Отката (Rollback): { например, Автоматический откат при сбое проверки работоспособности после развертывания, Ручной запуск через задачу CI/CD, откат состояния IaC. Укажите основной механизм. }

## Стратегия Обработки Ошибок

- **Общий Подход:** { Например, Использование Either type для возврата результата или ошибки в Domain Layer. Четко определенная иерархия пользовательских типов ошибок. }
- **Логирование:**
  - Библиотека/Метод: { Например, `dart:developer` для базового логирования, специализированные пакеты для логирования с уровнями и контекстом, интеграция с Firebase Crashlytics/Analytics для отчетов об ошибках. Укажите выбранную библиотеку. }
  - Формат: { Например, структурированный JSON, простой текст с отметкой времени и уровнем важности. JSON предпочтителен для структурированного логирования. }
  - Уровни: { Например, DEBUG, INFO, WARN, ERROR, FATAL. Укажите стандартное использование для каждого. }
  - Контекст: { Какая контекстная информация должна быть включена? Например, Correlation ID (если применимо), User ID (если применимо и безопасно), Название Фичи/Модуля, Название Операции, Ключевые Параметры (санитизированные). }
- **Специфические Шаблоны Обработки:**
  - Вызовы Внешних API (Supabase, Firebase): { Определите механизмы повторных попыток (например, exponential backoff, максимальное количество попыток - укажите библиотеку, если она обязательна), использование шаблона Circuit Breaker (укажите, если и как), конфигурации таймаутов. Как ошибки API (4xx, 5xx) преобразуются или распространяются? }
  - Внутренние Ошибки / Исключения Бизнес-логики: { Как преобразовывать внутренние ошибки в ошибки, видимые пользователю (если применимо, например, общие сообщения об ошибках с уникальным ID для поддержки, специфические коды ошибок). Существуют ли определенные классы бизнес-исключений? }
  - Управление Транзакциями: { Подход для обеспечения консистентности данных в случае ошибок во время многошаговых операций, например, транзакции базы данных (Supabase/PostgreSQL), использование паттерна Saga для распределенных транзакций (укажите оркестратор/хореографию и логику компенсации), особенно для операций с несколькими сервисами (Supabase Auth + Database). }

## Стандарты Кодирования

{ Эти стандарты обязательны для всей генерации кода AI агентами и написанного человеком кода. Отклонения не допускаются, если явно не одобрены и задокументированы как исключение в этом разделе или связанном дополнении. }

- **Основная Среда Выполнения (Runtime):** { Flutter 3.x - см. Окончательный Выбор Технологического Стека }
- **Руководство по Стилю & Линтер:** { Например, `dart format` для автоматического форматирования; `dart analyze` с жесткими правилами из `analysis_options.yaml`. Ссылайтесь на конфигурационный файл. Правила линтера обязательны и не должны отключаться без причины. }
- **Соглашения по Именованию:**
  - Переменные: `{ camelCase }`
  - Функции/Методы: `{ camelCase }`
  - Классы/Типы: `{ PascalCase }`
  - Константы: `{ UPPER_SNAKE_CASE }`
  - Файлы: `{ snake_case.dart }`
  - Модули/Пакеты: `{ snake_case }`
- **Структура Файлов:** Adhere к структуре, определенной в разделе "Структура Проекта" и, если применимо, в Документе Архитектуры Фронтенда.
- **Организация Файлов Модульных Тестов:** { `*_test.dart` co-located с исходными файлами в директории `test`. }
- **Асинхронные Операции:** { Всегда используйте `async`/`await` для операций, основанных на `Future` и `Stream`. Четкие паттерны для обработки ошибок и завершения. }
- **Типобезопасность (Type Safety):** { Максимально используйте систему типов Dart. Используйте Null Safety. Избегайте `dynamic`, где это возможно. }
  - _Определения Типов:_ { Местоположение, например, в файлах сущностей домена, моделях данных или общих файлах типов. Политика использования `dynamic` или эквивалента (крайне не рекомендуется, требует обоснования). }
- **Комментарии & Документация:**
  - Кодовые Комментарии: { Ожидания для кодовых комментариев: Объясняйте _почему_, а не _что_, для сложной логики. Избегайте избыточных комментариев. Используйте стандартные форматы DartDoc. }
  - README: { Каждый модуль/пакет/фича должен иметь README, объясняющий его назначение, настройку и использование, если это не тривиально. }
- **Управление Зависимостями:** { Инструмент: `pubspec.yaml` и `flutter pub get`/`pub get`. Политика добавления новых зависимостей (например, процесс утверждения, проверка существующих альтернатив, сканирование уязвимостей безопасности). Укажите стратегию версионирования (например, предпочтение привязанных версий, использование тильды `~` для патчей, каретки `^` для минорных обновлений - будьте специфичны). }

### Детальные Соглашения по Языку & Фреймворку

{ Для каждого основного языка и фреймворка, выбранного в "Окончательный Выбор Технологического Стека", **должны** соблюдаться следующие специфические соглашения. Если выбранная технология не перечислена ниже, это подразумевает соблюдение ее стандартных, широко принятых best practices и общих рекомендаций в этом документе. }

#### Dart / Flutter Специфика:

- **Иммутабельность:** { Всегда предпочитайте иммутабельные структуры данных. Используйте `final` для полей. Для сложных объектов рассмотрите библиотеки типа Freezed. Избегайте прямого изменения объектов/списков, переданных в виджеты или стейт. }
- **Функциональный против ООП:** { Используйте классы для сущностей (Domain Layer), репозиториев (Domain/Data), BLoC/Cubit, сервисов (DI). Используйте функции для преобразования данных и бизнес-логики (Use Cases). }
- **Специфика Обработки Ошибок:** { Используйте `Either<Failure, Success>` в Domain Layer для представления результатов операций (успех или ошибка). Определите иерархию `Failure` (например, `ServerFailure`, `CacheFailure`). Обрабатывайте ошибки в Use Cases и передавайте их в BLoC/Cubit для представления UI. }
- **Обработка Null/Undefined:** { Полностью используйте Null Safety. Избегайте принудительного разворачивания `!` без уверенности. Используйте `?.` (null-aware access) и `??` (null-aware coalescing). Четко определяйте nullable и non-nullable типы. }
- **Система Модулей:** { Используйте систему пакетов Dart (`import`/`export`). }
- **Специфика Логирования:** { Используйте выбранную библиотеку логирования или `dart:developer`. Логи ошибок должны включать контекст (стек вызовов, параметры). Не логируйте чувствительные данные. Используйте соответствующие уровни логирования. Интегрируйте с Firebase Crashlytics. }
- **Идиомы Фреймворка (Flutter):** { Используйте StatelessWidget/StatefulWidget соответствующим образом. Предпочитайте StatelessWidget, где это возможно. Используйте виджеты Flutter SDK и Material 3. Следуйте рекомендациям по композиции виджетов. Используйте Provider/BLoC/GetIt для доступа к зависимостям и стейту. }
- **Соглашения по Использованию Ключевых Библиотек:** { Например, при использовании Supabase SDK, используйте репозитории в Data Layer для абстракции доступа к данным. При использовании GetIt, регистрируйте зависимости в отдельном файле. Для навигации используйте GoRouter. }
- **Анти-паттерны Генерации Кода, которых Следует Избегать:** { Избегайте чрезмерно вложенной условной логики. Избегайте однобуквенных названий переменных (кроме тривиальных счетчиков циклов). Не пишите код, который обходит функции безопасности фреймворка или бэкенда (например, прямые небезопасные SQL-запросы). Избегайте "адских" колбэков, предпочитайте `async/await`. }

## Общая Стратегия Тестирования

{ Этот раздел описывает комплексную стратегию тестирования проекта, которой должен придерживаться весь код, генерируемый AI и написанный человеком. Он дополняет инструменты тестирования, перечисленные в разделе "Окончательный Выбор Технологического Стека". }

- **Инструменты:** { Повторите основные фреймворки и библиотеки для тестирования из Технологического Стека, например, `flutter test`, mocktail, mockito. }
- **Модульные Тесты (Unit Tests):**
  - **Область:** { Тестирование отдельных функций, методов, классов или небольших модулей в изоляции. Фокус на бизнес-логике (Use Cases), алгоритмах и правилах преобразования данных. Тестирование BLoC/Cubit без UI. }
  - **Местоположение:** { `*_test.dart` co-located с исходными файлами в директории `test/unit`. }
  - **Мокирование/Стаббинг:** { Укажите выбранную библиотеку для мокирования (например, mocktail, mockito). Мокируйте все внешние зависимости (репозитории, источники данных). }
  - **Ответственность AI Агента:** { AI Агент должен генерировать модульные тесты, покрывающие все публичные методы, значимые пути логики, граничные случаи и условия ошибок для любого нового или измененного кода. }
- **Виджет-Тесты (Widget Tests):**
  - **Область:** { Тестирование отдельных виджетов или небольших экранов UI в изоляции или с минимальным набором зависимостей. Проверка правильности рендеринга, взаимодействия с пользователем и реакции на изменения стейта BLoC/Cubit. }
  - **Местоположение:** { `*_test.dart` в директории `test/widget`. }
  - **Мокирование/Стаббинг:** { Мокирование зависимостей (например, BLoC, сервисы), от которых зависит виджет. Использование `Provider` или GetIt для предоставления моков. }
  - **Ответственность AI Агента:** { AI Агент может быть tasked с генерацией виджет-тестов для новых или измененных виджетов и экранов. }
- **Интеграционные Тесты (Integration Tests):**
  - **Область:** { Тестирование взаимодействия нескольких компонентов или целых потоков в приложении, включая UI, бизнес-логику и взаимодействие с локальными сервисами (без реальных внешних зависимостей, таких как Supabase). Использование `integration_test` фреймворка. }
  - **Местоположение:** { `*_test.dart` в директории `test/integration`. }
  - **Среда:** { Тестирование на реальном устройстве или эмуляторе. Мокирование внешних API/сервисов на уровне источников данных или репозиториев. }
  - **Ответственность AI Агента:** { AI Агент может быть tasked с генерацией интеграционных тестов для критически важных пользовательских потоков. }
- **Тест Покрытие:**
  - **Цель:** { Укажите целевой процент покрытия кода, если есть (например, 80% покрытия строк/веток для модульных тестов). Это руководство; качество тестов важнее, чем сырые цифры покрытия. }
  - **Измерение:** { Инструмент: `flutter test --coverage`. }
- **Стратегия Мокирования/Стаббинга (Общая):** { Помимо специфических типов тестов, изложите общие принципы. Например, "Предпочитайте fakes или test doubles вместо обширного мокирования там, где это улучшает четкость и поддерживаемость тестов. Стремитесь к тестам, которые быстры, надежны и изолированы." }
- **Управление Тестовыми Данными:** { Как создаются, управляются и изолируются тестовые данные? Например, фабрики, фикстуры, скрипты настройки/очистки, специальные инструменты для генерации тестовых данных. }

## Лучшие Практики Безопасности

{ Изложите ключевые соображения безопасности, относящиеся к кодовой базе. Они обязательны и должны активно учитываться AI агентом в процессе разработки. }

- **Санитизация/Валидация Ввода:** { Укажите библиотеку/метод для ВСЕХ внешних вводов (данные из форм, данные от API). Например, 'Используйте {библиотека_валидации} для всех вводов. Валидация должна происходить на границе до обработки. Для данных из Supabase/Firebase убедитесь, что они соответствуют ожидаемым моделям.' }
- **Кодирование Вывода:** { Укажите, где и как должно выполняться кодирование вывода для предотвращения XSS и других атак инъекций. Например, 'Все динамические данные, отображаемые в UI, должны быть должным образом экранированы. Будьте осторожны при использовании `RichText` или отображении HTML.' }
- **Управление Секретами:** { Ссылайтесь на `docs/environment-vars.md` относительно хранения для разных сред. В коде доступ к секретам _только_ через выделенный модуль/сервис конфигурации (например, используя пакет `flutter_dotenv`). Никогда не хардкодьте секреты, не включайте их в систему контроля версий и не логируйте. Используйте безопасные методы для хранения API ключей и URL Supabase/Firebase. }
- **Безопасность Зависимостей:** { Политика проверки уязвимых зависимостей. Например, 'Запускать автоматизированные сканирования уязвимостей (`flutter pub outdated --mode=nullsafety` + сторонние инструменты) как часть CI. Обновлять уязвимые зависимости оперативно в зависимости от серьезности.' Политика добавления новых зависимостей (процесс проверки). }
- **Проверки Аутентификации/Авторизации:** { Где и как должны применяться эти проверки? Например, 'Все обращения к защищенным данным или функциям (локально или через Supabase/Firebase) должны включать проверку аутентификации пользователя. Авторизация (проверка разрешений/ролей) должна выполняться перед выполнением действия.' Используйте функции безопасности Supabase (например, Row Level Security, Policies). }
- **Принцип Наименьших Привилегий (Имплементация):** { Например, 'Пользователи (анонимные/аутентифицированные) в Supabase должны иметь только необходимые разрешения (SELECT, INSERT, UPDATE, DELETE) для конкретных таблиц/строк, к которым они обращаются (через RLS Policies). Учетные данные для доступа к сервисам (Firebase, Supabase) в приложении должны быть минимальными.' }
- **Безопасность API (Общая):** { Например, 'Использовать HTTPS для всех внешних соединений. Быть осторожным с данными, получаемыми от внешних API (Supabase/Firebase), всегда валидировать их перед использованием.' }
- **Обработка Ошибок & Раскрытие Информации:** { Убедитесь, что сообщения об ошибках в UI не раскрывают чувствительную информацию (стек вызовов, внутренние пути, детальные ошибки базы данных). Логируйте детальные ошибки на бэкенде (Supabase Functions, если используются) или через Firebase Crashlytics, предоставляйте пользователю общие сообщения или ID ошибки. }
- **Регулярные Аудиты Безопасности/Тестирование:** { Упомяните, если планируется, например, использование инструментов статического анализа кода (SAST) в CI. }
- **{Другие соответствующие практики, например, Безопасность загрузки файлов (через Supabase Storage), Безопасность управления сессиями, Шифрование данных в состоянии покоя (обеспечивается Supabase/Firebase) и при передаче (через HTTPS).}**

## Ключевые Ссылочные Документы

{ если есть }

## Журнал Изменений

| Изменение | Дата | Версия | Описание | Автор |
| ------ | ---- | ------- | ----------- | ------ |

---

**После внесения изменений рекомендуется перезагрузить приложение для применения новой конфигурации.

--- Ниже, Промпт для Дизайн-Архитектора (Если Проект имеет UI) для Создания Архитектуры Фронтенда ----**
